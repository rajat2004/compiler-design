//
// Generated by JTB 1.2
//



PARSER_BEGIN(SubScheme2)
import visitor.FreeVarFinder;
import syntaxtree.*;
import java.util.Vector;


public class SubScheme2 
{
   public static void main(String args[])
   {
      SubScheme2 parser;
      System.out.println("Reading from standard input. . .");
      parser = new SubScheme2(System.in);
      try
      {
         Node root = parser.Unit();
         System.out.println("Parsed successfully.");
         root.accept(new FreeVarFinder());
      }
      catch (ParseException e)
      {
         System.out.println(e.getMessage());
         System.out.println("Encountered errors during parse.");
      }
   }
}

class JTBToolkit {
   static NodeToken makeNodeToken(Token t) {
      return new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);
   }
}


PARSER_END(SubScheme2)

SKIP :
{
   " "
   | "\t"
   | "\n"
   | "\r"
   | "\f"
}

TOKEN :
{
   <LAMBDA: "lambda">
   | <IDENT: <LETTER> (<LETTER> | <DIGIT>)*>
   | <#LETTER: ["_", "a"-"z", "A"-"Z"]>
   | <#DIGIT: ["0"-"9"]>
}

Unit Unit() :
{
   NodeList n0 = new NodeList();
   Exp n1;
   NodeToken n2;
   Token n3;

   {
   }
}
{
   (
      n1=Exp()
      { n0.addNode(n1); }
   )+
   { n0.nodes.trimToSize(); }
   n3=<EOF> { 
      n3.beginColumn++; n3.endColumn++;
      n2 = JTBToolkit.makeNodeToken(n3);
   }
   
   { return new Unit(n0,n2); }
}

Exp Exp() :
{
   NodeChoice n0;
   NodeToken n1;
   Token n2;
   LambdaDecl n3;
   NodeSequence n4;
   NodeToken n5;
   Token n6;
   Exp n7;
   NodeListOptional n8 = new NodeListOptional();
   Exp n9;
   NodeToken n10;
   Token n11;
   NodeToken n12;
   Token n13;
   NodeSequence n14;
   NodeToken n15;
   Token n16;
   NodeToken n17;
   Token n18;
   Exp n19;
   NodeToken n20;
   Token n21;
   NodeToken n22;
   Token n23;

   {
   }
}
{
   (
      n2=<IDENT> { n1 = JTBToolkit.makeNodeToken(n2); }
      { n0 = new NodeChoice(n1, 0); }
   |
      LOOKAHEAD(2)
      n3=LambdaDecl()
      { n0 = new NodeChoice(n3, 1); }
   |
      LOOKAHEAD(2)
      { n4 = new NodeSequence(5); }
      n6="(" { n5 = JTBToolkit.makeNodeToken(n6); }
      { n4.addNode(n5); }
      n7=Exp()
      { n4.addNode(n7); }
      (
         n9=Exp()
         { n8.addNode(n9); }
      )*
      { n8.nodes.trimToSize(); }
      { n4.addNode(n8); }
      n11=")" { n10 = JTBToolkit.makeNodeToken(n11); }
      { n4.addNode(n10); }
      { n0 = new NodeChoice(n4, 2); }
   |
      n13="0" { n12 = JTBToolkit.makeNodeToken(n13); }
      { n0 = new NodeChoice(n12, 3); }
   |
      { n14 = new NodeSequence(5); }
      n16="(" { n15 = JTBToolkit.makeNodeToken(n16); }
      { n14.addNode(n15); }
      n18="+" { n17 = JTBToolkit.makeNodeToken(n18); }
      { n14.addNode(n17); }
      n19=Exp()
      { n14.addNode(n19); }
      n21="1" { n20 = JTBToolkit.makeNodeToken(n21); }
      { n14.addNode(n20); }
      n23=")" { n22 = JTBToolkit.makeNodeToken(n23); }
      { n14.addNode(n22); }
      { n0 = new NodeChoice(n14, 4); }
   )
   
   { return new Exp(n0); }
}

LambdaDecl LambdaDecl() :
{
   NodeToken n0;
   Token n1;
   NodeToken n2;
   Token n3;
   NodeToken n4;
   Token n5;
   NodeListOptional n6 = new NodeListOptional();
   NodeToken n7;
   Token n8;
   NodeToken n9;
   Token n10;
   Exp n11;
   NodeToken n12;
   Token n13;

   {
   }
}
{
   n1="(" { n0 = JTBToolkit.makeNodeToken(n1); }
   n3="lambda" { n2 = JTBToolkit.makeNodeToken(n3); }
   n5="(" { n4 = JTBToolkit.makeNodeToken(n5); }
   (
      n8=<IDENT> { n7 = JTBToolkit.makeNodeToken(n8); }
      { n6.addNode(n7); }
   )*
   { n6.nodes.trimToSize(); }
   n10=")" { n9 = JTBToolkit.makeNodeToken(n10); }
   n11=Exp()
   n13=")" { n12 = JTBToolkit.makeNodeToken(n13); }
   
   { return new LambdaDecl(n0,n2,n4,n6,n9,n11,n12); }
}
