JJTree and JTB: A Hands-On Comparison
-------------------------------------

Modified for use with JJTree 1.0, JavaCC 1.0 and JTB 1.2, July 6, 1999

In order to experience first-hand the differences between programming  
using JJTree and JTB, we decided the best course of action would be to 
take a small task that would be a typical use of parse trees and use both 
JJTree and JTB.  The result is this example.

The task we decided on was to find free (or undeclared) variables in a 
tiny subset of the Scheme grammar.  Specifically, this grammar is as 
follows:

Expression ::= <IDENTIFIER>
               | "(" "lambda" "(" ( <IDENTIFIER> )* Expression ")"
               | "(" Expression ( Expression )* ")"
               | "0"
               " "(" "+" Expression "1" ")"

This comparison has been tested with JJTree 1.0 (included with JavaCC 
1.0) and JTB 1.2.

There are three directories in this package:

   o jjtree/            Contains the JJTree example
   o jtb/               Contains the first JTB example
   o jtb2/              Contains the second JTB example

The difference between the first and second JTB examples is that the 
first uses the unmodified grammar above.  The second takes the second 
line in the production above and makes a new nonterminal out of it:

Declaration ::= "(" "lambda" "(" ( <IDENTIFIER> )* Expression ")"

This slightly simplifies the visitor and shows how you can modify the 
grammar to improve its programmability with JTB.

Also included is the file sample.dat, a sample input.


JJTree
------

There are three files involved with this example:

subscheme.jjt -- The annotated grammar file for use with JJTree.  A good
   amount of time was spent planning the parse tree and annotating the 
   grammar file accordingly, as well as testing the parse tree after 
   annotating was complete.  I decided on putting each choice of the 
   Expression production in its own node, with a name descriptive of its
   intent, namely Declaration, FunctionCall, ZeroConstant, and AddExp.

   Also notice that in order to store identifiers in the parse tree, a
   separate production called Identifier had to be made with code to store
   the token in the ASTIdentifier node.

ASTIdentifier.java -- An edited node originally generated by JJTree.  I had
   to add a String variable to the class to store the identifier.

FreeVarFinder.java -- The visitor I programmed to find free variables.  A 
   couple of things different from JTB:

      o I had to manually create visit() methods to do nothing but visit the
        node's children.  This is not necessary with JTB.
      o You have to be very careful when accessing node children since you
        don't have their explicit type.  This is because they are stored as
        a Vector.  I had to spend some time debugging incorrect code when I
        thought a child at element 0 wasn't what I expected, etc.

All in all, programming using JJTree wasn't as difficult as I had imagined.
I do believe that the problems I noticed would be more significant in a
larger project.


JTB 1
-----

There are two files aside from the ones generated by JTB.

subscheme.jj -- The plain grammar file as well as the main class.

visitor/FreeVarFinder -- The visitor I programmed for JTB.  First of all
   you'll notice it has only one method.  This is because it extends the
   superclass Visitor which by default visits all the nodes in the tree.
   Thus, only visit() methods which need to perform a specific task need
   to be overridden.

The switch statement in visit(Exp n) is a little messy, with a few
neccessary typecasts and nested special nodes (i.e. NodeSequence and
NodeListOptional).  However, the code is still fairly clean.

It also took around 10 minutes to complete as opposed to 30 for the JJTree
example (granted, I am not a JJTree expert and I am pretty proficieint
with JTB).  However, the extra time spent on JJTree was with the planning
and debugging of the syntax tree, steps unnecessary with JTB.


JTB 2
-----

This differs from the first example in that a new nonterminal "Declaration"
has been created specifically for declarations, rather than having it inlined
in Expression.

This cleans up the visitor code somewhat, since no special nodes need to be
nested (and thus traversed).  It also eliminates the need for any typecasts.


Conclusion
----------

As you can see, the JTB examples are, in general, simpler.  Depending on your
primary needs, JJTree's added complexity may be necessary, for example, if
you need to specify how the tree will look or minimize on memory usage.

Also see http://www.cs.purdue.edu/jtb/tools.html for an in-depth comparison
of JJTree and JTB.  If you have any questions or comments, feel free to
contact us by email.

Original Author:   Kevin Tao
Current Developer: Wanjun Wang (wanjun@purdue.edu)
Supervisor:        Jens Palsberg (palsberg@cs.purdue.edu)