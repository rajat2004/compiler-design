//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;



class BasicBlock {
	ArrayList<String> statements = new ArrayList<String>();
	int lineNo;
	String label;
	
	Node root;
	
	ArrayList<String> use = new ArrayList<String>();
	ArrayList<String> def = new ArrayList<String>();
	HashSet<String> in = new HashSet<String>();
	HashSet<String> out = new HashSet<String>();
	
	HashSet<BasicBlock> succ = new HashSet<BasicBlock>();
//	HashSet<BasicBlock> pred = new HashSet<BasicBlock>();
}


// Data to be stored for each Procedure
class ProcedureClass{
	ArrayList<BasicBlock> proc_blocks = new ArrayList<BasicBlock>();
	String label = "";
	int procLineNo = 0;
	
	int no_args = 0, stack_slots = 0, maxCallArgs = 0;
	
	boolean spilled = false;
}


/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class Liveliness<R,A> extends GJDepthFirst<R,A> {
	
	boolean debug = true;
	
	ArrayList<ProcedureClass> allProcedures = new ArrayList<ProcedureClass>();
	ArrayList<BasicBlock> lines = new ArrayList<BasicBlock>();
	
	HashMap<String, BasicBlock> labelSeen = new HashMap<String, BasicBlock>();
	HashMap<String, ArrayList<BasicBlock>> labelsToBeFilled = new HashMap<String, ArrayList<BasicBlock>>();
	
	int lineNo = 0;
	String currlabel = "";
	
	BasicBlock curr_line = new BasicBlock();
	BasicBlock prev_line = new BasicBlock();
	ProcedureClass curr_proc = new ProcedureClass();
	
	boolean use = false;
	
	
	void print(String s) {
		if (debug)
			System.out.println(s);
	}
	
	void printProcLines() {
		if (debug) {
			for (ProcedureClass p : allProcedures) {
				System.out.println(Integer.toString(p.procLineNo) + ": " + p.label );
				for (BasicBlock l : p.proc_blocks) {
					System.out.println(l.lineNo + ": "  + l.statements);
					System.out.println("Use: " + l.use);
					System.out.println("Def: " + l.def);
					System.out.print("Succ: ");
					for (BasicBlock s : l.succ) {
						System.out.print(s.lineNo + ", ");
					}
					System.out.println();
				}
				
				System.out.println("\n");
			}
		}
	}
	
	
	
	void livelinessAnalysis() {
		// Run for each procedure
		for (ProcedureClass p : allProcedures) {
			boolean flag = true;
			
			while (flag) {
				flag = false;
				for (BasicBlock l : p.proc_blocks) {
					boolean outFlag = false;
					boolean inFlag = false;
					HashSet<String> tmp_out = new HashSet<String>();
					for (BasicBlock s : l.succ) {
						tmp_out.addAll(s.in);
					}
					
					if (l.out.containsAll(tmp_out)) {
						outFlag = true;
					} else {
						l.out = tmp_out;
					}
					
					
				}
			}
		}
	}
	
	
	
	void finish() {
		printProcLines();
	}
	
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() ) {
    	  R _ret =  n.node.accept(this,argu);
    	  lineNo++;
    	  curr_line = new BasicBlock();
    	  curr_line.lineNo = lineNo;
    	  lines.add(curr_line);
    	  
    	  if (prev_line != null) {
    		  prev_line.succ.add(curr_line);
    	  }
    	  
    	  // New label start, so add succ in all the lines which point to this
    	  String label = (String) _ret;
    	  
    	  if (labelsToBeFilled.containsKey(label)) {
    		  for (BasicBlock l : labelsToBeFilled.get(label)) {
    			  l.succ.add(curr_line);
    		  }
    		  
    		  labelsToBeFilled.remove(label);
    	  }
    	  
    	  labelSeen.put(label, curr_line);
    	  prev_line = curr_line;
    	  
    	  return _ret;
      }
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      
      curr_proc = new ProcedureClass();
      curr_proc.label = "MAIN";
      curr_proc.no_args = 0;
      
      lineNo++;
      n.f0.accept(this, argu);
      
      curr_proc.procLineNo = lineNo;
      
      n.f1.accept(this, argu);
      
      lineNo++;
      n.f2.accept(this, argu);
      
      curr_proc.proc_blocks = lines;
      lines = new ArrayList<BasicBlock>();
      allProcedures.add(curr_proc);
      
      curr_proc = new ProcedureClass();
      
      n.f3.accept(this, argu);
      
      n.f4.accept(this, argu);
      
      finish();
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      
      ProcedureClass curr_proc = new ProcedureClass();
      curr_proc.label = n.f0.f0.tokenImage;
      curr_proc.no_args = Integer.parseInt(n.f2.f0.tokenImage);

      lineNo++;
      curr_proc.procLineNo = lineNo;
//      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
//      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      
      curr_proc.proc_blocks = lines;
      lines = new ArrayList<BasicBlock>();
      allProcedures.add(curr_proc);
      
      curr_proc = new ProcedureClass();
      prev_line = null;
      
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
//      R _ret=null;
//      curr_line = new BasicBlock();
//      curr_line.label = currlabel;
//      ArrayList<String> ret = (ArrayList<String>)(n.f0.accept(this, argu));
//      curr_line.statements = ret;
//      lineNo++;
//      curr_line.lineNo = lineNo;
//      
//      lines.add(curr_line);
//      curr_line = new BasicBlock();
	   
	   R _ret = null;
	   n.f0.accept(this, argu);
      
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      lineNo++;
      
      
      curr_line = new BasicBlock();
      curr_line.lineNo = lineNo;

      curr_line.statements.add("NOOP");
      
      if (prev_line != null) {
//    	  curr_line.pred.add(prev_line);
    	  prev_line.succ.add(curr_line);
      }
      
      prev_line = curr_line;
      lines.add(curr_line);
      
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
     R _ret=null;
     n.f0.accept(this, argu);
     lineNo++;
     
     curr_line = new BasicBlock();
     curr_line.lineNo = lineNo;
     curr_line.statements.add("ERROR");
     
     if (prev_line != null) {
//    	 curr_line.pred.add(prev_line);
    	 prev_line.succ.add(curr_line);
     }
     
     prev_line = curr_line;
     lines.add(curr_line);
     return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
	   R _ret=null;
	   n.f0.accept(this, argu);
//	   ArrayList<String> ret = new ArrayList<String>();
//	   ret.add("CJUMP");
	   
	   lineNo++;
	   
	   curr_line = new BasicBlock();
	   curr_line.lineNo = lineNo;
	   curr_line.statements.add("CJUMP");
	   
	   if (prev_line != null)
		   prev_line.succ.add(curr_line);
	   
	   String label = n.f2.f0.tokenImage;
		  
	   if (labelSeen.containsKey(label)) {
		   curr_line.succ.add(labelSeen.get(label));
	   }
	   else {
		   if (labelsToBeFilled.containsKey(label)) 
			   labelsToBeFilled.get(label).add(curr_line);	
		   else {
			   labelsToBeFilled.put(label, new ArrayList<BasicBlock>());
			   labelsToBeFilled.get(label).add(curr_line);
		   }
	   }
	   lines.add(curr_line);
	   
	   use = true;
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      prev_line = curr_line;
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      lineNo++;
      
      curr_line = new BasicBlock();
	  curr_line.lineNo = lineNo;
	  curr_line.statements.add("JUMP");
	  
	  if (prev_line != null)
		  prev_line.succ.add(curr_line);
	  
	  String label = n.f1.f0.tokenImage;
	  
	  if (labelSeen.containsKey(label)) {
		  curr_line.succ.add(labelSeen.get(label));
	  }
	  else {
		  if (labelsToBeFilled.containsKey(label)) 
			  labelsToBeFilled.get(label).add(curr_line);
		  else {
			  labelsToBeFilled.put(label, new ArrayList<BasicBlock>());
			  labelsToBeFilled.get(label).add(curr_line);
		  }
	  }
	  
	  prev_line = null;
	  lines.add(curr_line);
	  
	   
      n.f0.accept(this, argu);
//      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      lineNo++;
      curr_line = new BasicBlock();
      curr_line.lineNo = lineNo;
      curr_line.statements.add("HSTORE");
      
      if (prev_line != null)
    	  prev_line.succ.add(curr_line);
      
      use = true;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      
      lines.add(curr_line);
      prev_line = curr_line;
      
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      lineNo++;
      
      curr_line = new BasicBlock();
      curr_line.lineNo = lineNo;
      curr_line.statements.add("HLOAD");
      
      if (prev_line != null)
    	  prev_line.succ.add(curr_line);
      
      n.f0.accept(this, argu);
      
      use = false;
      n.f1.accept(this, argu);
      
      use = true;
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      
      lines.add(curr_line);
      prev_line = curr_line;
      
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      lineNo++;
      
      curr_line = new BasicBlock();
      curr_line.lineNo = lineNo;
      curr_line.statements.add("MOVE");
      
      if (prev_line != null)
    	  prev_line.succ.add(curr_line);
      
      n.f0.accept(this, argu);
      use = false;
      n.f1.accept(this, argu);
      use = true;
      n.f2.accept(this, argu);
      
      lines.add(curr_line);
      prev_line = curr_line;
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      lineNo++;
      
      curr_line = new BasicBlock();
      curr_line.lineNo = lineNo;
      curr_line.statements.add("PRINT");
      
      if (prev_line != null)
    	  prev_line.succ.add(curr_line);
      
      n.f0.accept(this, argu);
      use = true;
      n.f1.accept(this, argu);
      
      lines.add(curr_line);
      prev_line = curr_line;
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      lineNo++;
      
      curr_line = new BasicBlock();
      curr_line.lineNo = lineNo;
      curr_line.statements.add("BEGIN");
      
      prev_line = curr_line;
      
      n.f1.accept(this, argu);
      
      n.f2.accept(this, argu);
      lineNo++;
      
      use = true;
      n.f3.accept(this, argu);
      
      n.f4.accept(this, argu);
      lineNo++;
      
      prev_line = null;
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      use = true;
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      use = true;
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      use = true;
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      
      if (use)
    	  curr_line.use.add(n.f1.f0.tokenImage);
      else
    	  curr_line.def.add(n.f1.f0.tokenImage);
      
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return (R)n.f0.tokenImage;
   }

}
